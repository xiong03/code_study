# -*- coding: utf-8 -*-
# ---------------------------------------------------------------------------
# 道路河流.py
# Created on: 2022-06-23 09:07:44.00000
#   (generated by ArcGIS/ModelBuilder)
# Description: 
# ---------------------------------------------------------------------------

# Import arcpy module
import xlrd
import arcpy
import sys
import os
from glob import glob as glb
from arcpy import env
from arcpy.sa import *
reload(sys)
sys.setdefaultencoding("utf-8")

arcpy.env.overwriteOutput = True
arcpy.CheckOutExtension("spatial")        # Check out the ArcGIS Spatial Analyst extension license




sheet_col = []
a = []
value = []
coast = []
lst = []
# shp处理
shp_path = r"D:\work\0stld\22shp\22shp"
shp_lists = os.listdir(shp_path)
classfile = r"D:\work\0stld\edit\class.xls"
types = xlrd.open_workbook(classfile)
sheet=types.sheet_by_index(0)  # 获取第一个sheet

# 读取分类表数据
for n in range(0,6):
    col=sheet.col_values(n)
    sheet_col.append(col)
# 读取shp
x = 0
table = []
for shp_list in shp_lists:
    shp_list = unicode(shp_list, 'gbk')

    # 判断该地区是否有森林公园
    def judgment(f_path):
        '''
        :param file:
        :return:
        '''
        global judg
        forestes = glb(f_path)
        for forest in forestes:
            forest = unicode(forest, 'gbk')
            if forest.split("\\")[-1].split(".")[0] in shp_list:
                if arcpy.management.GetCount(forest)[0] == "0":  # 判断要素是否为空
                    judg = 0
                    break
                else:
                    judg = 1
                    break
            elif shp_list in "上饶物流园土地使用规划图":
                judg = 0
                break
        return judg,forest
    jud,forest = judgment(r"D:\work\0stld\22shp\forest\*.shp")
    if jud == 0:
        print(shp_list+"is null")
        continue

    else:
        print(shp_list)
        shp_name = shp_path + os.sep + shp_list + os.sep + "*.shp"
        shp_paths = glb(shp_name)[0]
       # 创建对应的文件夹
       #  fill_name =shp_paths.split("\\")[-1].split(".")[0]
        dirs = r"D:\work\0stld\temp\{}".format(x)
        x += 1
        if not os.path.exists(dirs):
            os.makedirs(dirs)
        elif os.path.exists(dirs):
            continue

        shp_sv_tif_temp = dirs + os.sep + shp_list + "_temp.tif"
        shp_sv_tif = dirs + os.sep + shp_list + ".tif"
        #Process: 面转栅格
        print("Process: 面转栅格")
        arcpy.PolygonToRaster_conversion(shp_paths, "LNAME", shp_sv_tif_temp, "CELL_CENTER", "NONE", "2")

        # Process: 添加字段
        print("Process: 添加字段")
        arcpy.AddField_management(shp_sv_tif_temp, "coast", "LONG", "", "", "", "", "NULLABLE", "NON_REQUIRED", "")

        # Process:使用字段计算器赋值
        print("Process: 字段赋值")
        with arcpy.da.UpdateCursor(shp_sv_tif_temp, ['LNAME',"coast"]) as cursor:
            for row in cursor:
                if row[0] in sheet_col[0]:
                    row[1] = 5
                elif row[0] in sheet_col[1]:
                    row[1] = 5
                elif row[0] in sheet_col[2]:
                    row[1] = 50
                elif row[0] in sheet_col[3]:
                    row[1] = 150
                elif row[0] in sheet_col[4]:
                    row[1] = 10
                else:
                    row[1] = 1
                cursor.updateRow(row)


        def fun(path, outpath):
            """
            :param path: 需要重分类的数据（含coast字段）
            :param outpath:
            :return:
            """
            # 用于存储字段coast值
            table = []

            # 先赋值value为5和10
            with arcpy.da.SearchCursor(path, 'coast') as cursor:
                for i, row in enumerate(cursor):
                    # print(i)
                    if i == 0:
                        outCon = Con(Raster(path) == i + 1, row[0], Raster(path))
                    elif i == 9 or i == 4:
                        outCon = Con(outCon == i + 1, row[0], outCon)
                    else:
                        table.append([i, row[0]])
                # 对剩下赋值
                for i, row in table:
                    # print(i)
                    outCon = Con(outCon == i + 1, int(row), outCon)

                intCon = Int(outCon)
                intCon.save(outpath)

                print('save successful')
        fun(shp_sv_tif_temp, shp_sv_tif)

        # 道路河流处理
        path = r'D:\work\0stld\road2000\*.shp'
        paths = glb(path)
        for pth in paths:
            name = pth.split("\\")[-1].split("_")[0]
            if name == "highway":
                hcrange = "20 Meters"
                coastvalue = 200
            if name == "railway":
                hcrange = "30 Meters"
                coastvalue = 300
            if name == "road":
                hcrange = "15 Meters"
                coastvalue = 150
            if name == "river":
                hcrange = "8 Meters"
                coastvalue = 80

            # Local variables:
            save = dirs + os.sep
            temp_file = save + "temp"
            highway_2000_shp = pth
            highway_2000_shp_clip = temp_file + os.sep + name + "_clip.shp"
            highway_coast_tif = dirs + os.sep + name + "_coast.tif"
            a.append(highway_coast_tif)
            highway_2000_buffer_shp = temp_file + os.sep + name + "_buffer.shp"
            if not os.path.exists(temp_file):
                os.makedirs(temp_file)

            # 裁剪
            try:
                arcpy.analysis.Clip(highway_2000_shp, shp_paths, highway_2000_shp_clip)
                if arcpy.management.GetCount(highway_2000_shp_clip)[0] == "0": #判断要素是否为空
                    print(name+"null")
                    arcpy.DeleteFeatures_management(highway_2000_shp_clip)
                    continue
                else:
                    print(name)
                    # Process: 缓冲区
                    print("Process: 缓冲区")
                    arcpy.Buffer_analysis(highway_2000_shp_clip, highway_2000_buffer_shp, hcrange, "FULL", "ROUND", "NONE", "")

                    # Process: 添加字段
                    print("Process: 添加字段")
                    arcpy.AddField_management(highway_2000_buffer_shp, "coast", "LONG", "", "", "", "", "NULLABLE", "NON_REQUIRED",
                                              "")

                    # Process:使用字段计算器赋值
                    print("Process: 字段赋值")
                    data = highway_2000_buffer_shp
                    arcpy.CalculateField_management(data, 'coast', coastvalue, 'PYTHON_9.3')

                    # Process: 面转栅格
                    print("Process: 面转栅格")
                    arcpy.PolygonToRaster_conversion(highway_2000_buffer_shp, "coast", highway_coast_tif, "CELL_CENTER", "NONE",
                "5")
            except:
                table.append(shp_list)
                break

        # 镶嵌
        # Process: 镶嵌至新栅格
        print("Process: 镶嵌至新栅格")
        highway = a[0]
        railway = a[1]
        road = a[2]
        lake = a[3]

        temp = temp_file + os.sep
        arcpy.MosaicToNewRaster_management("{};{};{};{};{}".format(shp_sv_tif,highway,railway,road,lake), temp_file, "cost_temp.tif", shp_sv_tif, "8_BIT_UNSIGNED", "5", "1", "MAXIMUM", "FIRST")

        # f_path = r"D:\work\0stld\22shp\forest\*.shp"
        cost_tif_temp = temp + "cost_temp.tif"
        cost_tif = save + "cost.tif"



        langdao_shp = temp + "langdao.shp"

        # 条件函数
        outCon = Con(Raster(cost_tif_temp) == 0, 150, cost_tif_temp)
        outCon.save(cost_tif)

        # # Process: 创建常量栅格
        # tempEnvironment0 = arcpy.env.extent
        # desc = arcpy.Describe(shp_paths)
        # LIS = '{} {} {} {}'.format(desc.extent.XMin, desc.extent.YMin, desc.extent.XMax, desc.extent.YMax)
        # arcpy.gp.CreateConstantRaster_sa(constant_tif, "150", "INTEGER",cost_tif, LIS)
        # arcpy.env.extent = tempEnvironment0
        # # Process: 镶嵌至新栅格
        # arcpy.MosaicToNewRaster_management("{};{}".format(cost_tif, constant_tif), dirs, "cost_mosaic.tif", cost_tif, "8_BIT_UNSIGNED", "5", "1", "FIRST", "FIRST")

        # Process: 成本距离
        tempEnvironment0 = arcpy.env.extent
        arcpy.env.extent = "MAXOF"

        # 创建矢量图层
        arcpy.MakeFeatureLayer_management(forest, 'lyr')
        with arcpy.da.SearchCursor('lyr', 'FID') as cursor:
            i = 0
            for row in cursor:
                result_shp = save + "result" + "_" + str(i) + ".shp"
                final_tif = temp + "final" + "_" + str(i) + ".tif"
                huisu_tif = temp + "huisu" + "_" + str(i) + ".tif"
                langdao_tif = temp + "langdao" + "_" + str(i) + ".tif"
                langdao_tif1 = temp + "langdao1" + "_" + str(i) + ".tif"
                arcpy.SelectLayerByAttribute_management('lyr', 'NEW_SELECTION', 'FID = {}'.format(row[0]))

                print("Process: 成本距离")

                arcpy.gp.CostDistance_sa('lyr', cost_tif, final_tif, "", huisu_tif)
                arcpy.env.extent = tempEnvironment0

                arcpy.SelectLayerByAttribute_management('lyr', 'NEW_SELECTION', 'NOT FID = {}'.format(row[0]))

                # Process: 成本路径
                print("Process: 成本路径")
                arcpy.gp.CostPath_sa('lyr', final_tif, huisu_tif, langdao_tif, "EACH_CELL", "FID")

                outSetNull = SetNull(langdao_tif, langdao_tif, "VALUE = 0")
                outSetNull.save(langdao_tif1)

                # Process: 栅格转面
                print("Process: 栅格转面")
                arcpy.RasterToPolygon_conversion(langdao_tif1, langdao_shp, "SIMPLIFY", "Value")
                # Process: 修复几何
                print("Process: 修复几何")
                arcpy.RepairGeometry_management(forest)

                # Process: 交集取反
                try:
                    print("Process: 交集取反")
                    arcpy.SymDiff_analysis(langdao_shp, forest, result_shp, "ALL", "")
                except:
                    table.append(shp_list)
                    break

                # Process: 计算几何
                print("Process: 计算几何")
                fields = arcpy.ListFields(result_shp)
                # 读取其字段数据集
                fd = []
                for field in fields:
                    fd.append(field.name)
                if "AREA" not in fd:
                    arcpy.AddField_management(result_shp, "AREA", "FLOAT", "", "", "", "", "NULLABLE", "NON_REQUIRED",
                                          "")
                arcpy.CalculateField_management(result_shp, "AREA", "!shape.area@SQUAREMETERS!", "PYTHON_9.3")

                with arcpy.da.UpdateCursor(result_shp,["AREA"]) as cursor:
                    for row in cursor:
                        if row[0] >= 2000:
                            cursor.deleteRow()
                print("finish" + "_" + str(x))

                break
                i += 1
print("over")